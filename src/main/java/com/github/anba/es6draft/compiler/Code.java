/**
 * Copyright (c) 2012-2013 Andr√© Bargull
 * Alle Rechte vorbehalten / All Rights Reserved.  Use is subject to license terms.
 *
 * <https://github.com/anba/es6draft>
 */
package com.github.anba.es6draft.compiler;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.commons.CodeSizeEvaluator;

/**
 * Class encapsulating generated bytecode
 */
final class Code {
    private static final boolean EVALUATE_SIZE = false;
    private static final int METHOD_LIMIT = 1 << 12;

    private final List<ClassCode> classes = new ArrayList<>();
    private final ClassCode mainClass;
    private ClassCode currentClass;

    Code(String className, String superClassName, String fileName, String sourceMap) {
        mainClass = newMainClass(className, superClassName, fileName, sourceMap);
        currentClass(mainClass);
    }

    private void currentClass(ClassCode newCurrentClass) {
        classes.add(newCurrentClass);
        this.currentClass = newCurrentClass;
    }

    private ClassCode requestClassForMethod() {
        if (currentClass.methodCount() >= METHOD_LIMIT) {
            currentClass(newClass(mainClass, classes.size()));
        }
        return currentClass;
    }

    private static ClassCode newMainClass(String className, String superClassName, String fileName,
            String sourceMap) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,
                className, null, superClassName, null);
        cw.visitSource(fileName, sourceMap);

        return new ClassCode(className, cw);
    }

    private static ClassCode newClass(ClassCode mainClass, int temp) {
        String className = mainClass.className + '~' + temp;
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,
                className, null, "java/lang/Object", null);
        cw.visitSource(null, null);

        return new ClassCode(className, cw);
    }

    /**
     * Returns the list of generated {@link ClassCode} objects
     */
    List<ClassCode> getClasses() {
        return classes;
    }

    /**
     * Add a new method to main class module
     */
    MethodCode newMainMethod(int access, String methodName, String methodDescriptor) {
        return mainClass.newMethod(access, methodName, methodDescriptor, null, null);
    }

    /**
     * Add a new method to a class module
     */
    MethodCode newMethod(int access, String methodName, String methodDescriptor) {
        return requestClassForMethod().newMethod(access, methodName, methodDescriptor, null, null);
    }

    /**
     * Class representing method code
     */
    static final class MethodCode {
        final ClassCode classCode;
        final int access;
        final String methodName;
        final String methodDescriptor;
        final MethodVisitor methodVisitor;

        MethodCode(ClassCode classCode, int access, String methodName, String methodDescriptor,
                MethodVisitor methodVisitor) {
            this.classCode = classCode;
            this.access = access;
            this.methodName = methodName;
            this.methodDescriptor = methodDescriptor;
            this.methodVisitor = methodVisitor;
        }
    }

    /**
     * Class representing class code
     */
    static final class ClassCode {
        private int methodCount = 0;
        final String className;
        final ClassWriter classWriter;

        ClassCode(String className, ClassWriter classWriter) {
            this.className = className;
            this.classWriter = classWriter;
        }

        int methodCount() {
            return methodCount;
        }

        byte[] toByteArray() {
            classWriter.visitEnd();
            return classWriter.toByteArray();
        }

        MethodCode newMethod(int access, String methodName, String methodDescriptor,
                String signature, String[] exceptions) {
            methodCount += 1;
            MethodVisitor mv = classWriter.visitMethod(access, methodName, methodDescriptor,
                    signature, exceptions);
            if (EVALUATE_SIZE) {
                mv = new $CodeSizeEvaluator(methodName, mv);
            }
            return new MethodCode(this, access, methodName, methodDescriptor, mv);
        }
    }

    private static final class $CodeSizeEvaluator extends CodeSizeEvaluator {
        private final String methodName;

        $CodeSizeEvaluator(String methodName, MethodVisitor mv) {
            super(Opcodes.ASM4, mv);
            this.methodName = methodName;
        }

        @Override
        public void visitEnd() {
            System.out.printf("%s: [%d, %d]\n", methodName, getMinSize(), getMaxSize());
            super.visitEnd();
        }
    }
}
