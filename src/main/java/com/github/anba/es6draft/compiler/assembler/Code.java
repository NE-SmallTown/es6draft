/**
 * Copyright (c) 2012-2014 Andr√© Bargull
 * Alle Rechte vorbehalten / All Rights Reserved.  Use is subject to license terms.
 *
 * <https://github.com/anba/es6draft>
 */
package com.github.anba.es6draft.compiler.assembler;

import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

/**
 * Class encapsulating generated bytecode
 */
public final class Code {
    private static final int METHOD_LIMIT = 1 << 12;

    private final ArrayList<ClassCode> classes = new ArrayList<>();
    private final ClassCode mainClass;
    private ExternConstantPool sharedConstantPool = null;
    private ClassCode currentClass;

    public Code(String className, String superClassName, String fileName, String sourceMap) {
        mainClass = newMainClass(this, className, superClassName, fileName, sourceMap);
        classes.add(mainClass);
        setCurrentClass(mainClass);
    }

    private void setCurrentClass(ClassCode currentClass) {
        this.currentClass = currentClass;
    }

    private ClassCode requestClassForMethod() {
        if (currentClass.methodCount() >= METHOD_LIMIT) {
            setCurrentClass(newClass(new InlineConstantPool(this)));
        }
        return currentClass;
    }

    private static ClassCode newMainClass(Code code, String className, String superClassName,
            String fileName, String sourceMap) {
        ConstantPool constantPool = new InlineConstantPool(code);
        return newClass(constantPool, className, superClassName, fileName, sourceMap);
    }

    private static ClassCode newClass(ConstantPool constantPool, String className) {
        return newClass(constantPool, className, "java/lang/Object", null, null);
    }

    private static ClassCode newClass(ConstantPool constantPool, String className,
            String superClassName, String fileName, String sourceMap) {
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_7, Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL,
                className, null, superClassName, null);
        cw.visitSource(fileName, sourceMap);

        return new ClassCode(constantPool, className, cw);
    }

    /**
     * Returns the list of generated {@link ClassCode} objects.
     * 
     * @return the list of generated class code objects
     */
    public List<ClassCode> getClasses() {
        return classes;
    }

    /**
     * Returns the shared extern constant pool instance.
     * 
     * @return the extern constant pool
     */
    ConstantPool getSharedConstantPool() {
        if (sharedConstantPool == null) {
            sharedConstantPool = new ExternConstantPool(this);
        }
        return sharedConstantPool;
    }

    /**
     * Adds a new class.
     * 
     * @param constantPool
     *            the constant pool instance to use
     * @return the class code instance which represents the new class
     */
    ClassCode newClass(ConstantPool constantPool) {
        String className = mainClass.className + '~' + classes.size();
        ClassCode classCode = newClass(constantPool, className);
        classes.add(classCode);
        return classCode;
    }

    /**
     * Add a new method to main class module.
     * 
     * @param access
     *            the access flag
     * @param methodName
     *            the name of the new method
     * @param methodDescriptor
     *            the internal method descriptor
     * @return the method code instance which represents the new method
     */
    public MethodCode newMainMethod(int access, String methodName, String methodDescriptor) {
        return mainClass.newMethod(access, methodName, methodDescriptor, null, null);
    }

    /**
     * Add a new method to a class module.
     * 
     * @param access
     *            the access flag
     * @param methodName
     *            the name of the new method
     * @param methodDescriptor
     *            the internal method descriptor
     * @return the method code instance which represents the new method
     */
    public MethodCode newMethod(int access, String methodName, String methodDescriptor) {
        return requestClassForMethod().newMethod(access, methodName, methodDescriptor, null, null);
    }

    /**
     * Class representing method code
     */
    public static final class MethodCode {
        public final ClassCode classCode;
        public final int access;
        public final String methodName;
        public final String methodDescriptor;
        public final MethodVisitor methodVisitor;

        MethodCode(ClassCode classCode, int access, String methodName, String methodDescriptor,
                MethodVisitor methodVisitor) {
            this.classCode = classCode;
            this.access = access;
            this.methodName = methodName;
            this.methodDescriptor = methodDescriptor;
            this.methodVisitor = methodVisitor;
        }
    }

    /**
     * Class representing class code
     */
    public static final class ClassCode {
        private int methodCount = 0;
        public final ConstantPool constantPool;
        public final String className;
        public final ClassWriter classWriter;

        ClassCode(ConstantPool constantPool, String className, ClassWriter classWriter) {
            this.constantPool = constantPool;
            this.className = className;
            this.classWriter = classWriter;
        }

        public int methodCount() {
            return methodCount;
        }

        public byte[] toByteArray() {
            constantPool.close();
            classWriter.visitEnd();
            return classWriter.toByteArray();
        }

        public MethodCode newMethod(int access, String methodName, String methodDescriptor,
                String signature, String[] exceptions) {
            methodCount += 1;
            return new MethodCode(this, access, methodName, methodDescriptor,
                    classWriter.visitMethod(access, methodName, methodDescriptor, signature,
                            exceptions));
        }

        public void addField(int access, String fieldName, String fieldDescriptor, String signature) {
            classWriter.visitField(access, fieldName, fieldDescriptor, signature, null).visitEnd();
        }
    }
}
