/**
 * Copyright (c) 2012-2015 Andr√© Bargull
 * Alle Rechte vorbehalten / All Rights Reserved.  Use is subject to license terms.
 *
 * <https://github.com/anba/es6draft>
 */
package com.github.anba.es6draft.compiler.assembler;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.List;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.util.Printer;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceClassVisitor;

/**
 * Class encapsulating generated bytecode
 */
public final class Code {
    private static final int METHOD_LIMIT = 1 << 12;

    private final ArrayList<ClassCode> classes = new ArrayList<>();
    private final ClassCode mainClass;
    private ExternConstantPool sharedConstantPool = null;
    private ClassCode currentClass;

    public Code(int access, String className, Type superClass, String fileName, String sourceMap) {
        mainClass = newMainClass(this, access, className, superClass, fileName, sourceMap);
        classes.add(mainClass);
        setCurrentClass(mainClass);
    }

    private void setCurrentClass(ClassCode currentClass) {
        this.currentClass = currentClass;
    }

    private ClassCode requestClassForMethod() {
        if (currentClass.methodCount() >= METHOD_LIMIT) {
            setCurrentClass(newClass(new InlineConstantPool(this)));
        }
        return currentClass;
    }

    private static ClassCode newMainClass(Code code, int access, String className, Type superClass,
            String fileName, String sourceMap) {
        ConstantPool constantPool = new InlineConstantPool(code);
        String superClassName = superClass != null ? superClass.internalName() : null;
        return newClass(constantPool, access, className, superClassName, fileName, sourceMap);
    }

    private static ClassCode newClass(ConstantPool constantPool, int access, String className) {
        return newClass(constantPool, access, className, "java/lang/Object", null, null);
    }

    private static ClassCode newClass(ConstantPool constantPool, int access, String className,
            String superClassName, String fileName, String sourceMap) {
        if ((access & ~Modifier.classModifiers()) != 0) {
            throw new IllegalArgumentException();
        }
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
        cw.visit(Opcodes.V1_7, access | Opcodes.ACC_SUPER, className, null, superClassName, null);
        cw.visitSource(fileName, sourceMap);

        return new ClassCode(constantPool, className, cw);
    }

    /**
     * Returns the list of generated {@link ClassCode} objects.
     * 
     * @return the list of generated class code objects
     */
    public List<ClassCode> getClasses() {
        return classes;
    }

    /**
     * Returns the shared extern constant pool instance.
     * 
     * @return the extern constant pool
     */
    ConstantPool getSharedConstantPool() {
        if (sharedConstantPool == null) {
            sharedConstantPool = new ExternConstantPool(this);
        }
        return sharedConstantPool;
    }

    /**
     * Adds a new class.
     * 
     * @param constantPool
     *            the constant pool instance to use
     * @return the class code instance which represents the new class
     */
    ClassCode newClass(ConstantPool constantPool) {
        String className = mainClass.className + '~' + classes.size();
        int access = Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL;
        ClassCode classCode = newClass(constantPool, access, className);
        classes.add(classCode);
        return classCode;
    }

    /**
     * Add a new method to main class module.
     * 
     * @param access
     *            the access flag
     * @param methodDescriptor
     *            the method descriptor
     * @return the method code instance which represents the new method
     */
    public MethodCode newConstructor(int access, MethodTypeDescriptor methodDescriptor) {
        return mainClass.newConstructor(access, methodDescriptor, null, null);
    }

    /**
     * Add a new method to a class module.
     * 
     * @param access
     *            the access flag
     * @param methodName
     *            the name of the new method
     * @param methodDescriptor
     *            the method descriptor
     * @return the method code instance which represents the new method
     */
    public MethodCode newMethod(int access, String methodName, MethodTypeDescriptor methodDescriptor) {
        return requestClassForMethod().newMethod(access, methodName, methodDescriptor, null, null);
    }

    public static String toByteCode(byte[] bytes, boolean simpleTypes) {
        ClassReader cr = new ClassReader(bytes);
        Printer p;
        if (simpleTypes) {
            p = new SimpleTypeTextifier();
        } else {
            p = new Textifier();
        }
        cr.accept(new TraceClassVisitor(null, p, null), ClassReader.EXPAND_FRAMES);
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        p.print(pw);
        pw.flush();
        return sw.toString();
    }

    /**
     * Class representing method code
     */
    public static final class MethodCode {
        public final ClassCode classCode;
        public final int access;
        public final String methodName;
        public final MethodTypeDescriptor methodDescriptor;
        public final MethodVisitor methodVisitor;

        MethodCode(ClassCode classCode, int access, String methodName,
                MethodTypeDescriptor methodDescriptor, MethodVisitor methodVisitor) {
            this.classCode = classCode;
            this.access = access;
            this.methodName = methodName;
            this.methodDescriptor = methodDescriptor;
            this.methodVisitor = methodVisitor;
        }
    }

    /**
     * Class representing class code
     */
    public static final class ClassCode {
        private int methodCount = 0;
        public final ConstantPool constantPool;
        public final String className;
        public final Type classType;
        public final ClassWriter classWriter;

        ClassCode(ConstantPool constantPool, String className, ClassWriter classWriter) {
            this.constantPool = constantPool;
            this.className = className;
            this.classType = Type.forName(className);
            this.classWriter = classWriter;
        }

        public int methodCount() {
            return methodCount;
        }

        public byte[] toByteArray() {
            constantPool.close();
            classWriter.visitEnd();
            return classWriter.toByteArray();
        }

        public MethodCode newConstructor(int access, MethodTypeDescriptor methodDescriptor,
                String signature, String[] exceptions) {
            if ((access & ~Modifier.constructorModifiers()) != 0) {
                throw new IllegalArgumentException();
            }
            methodCount += 1;
            return new MethodCode(this, access, "<init>", methodDescriptor,
                    classWriter.visitMethod(access, "<init>", methodDescriptor.descriptor(),
                            signature, exceptions));
        }

        public MethodCode newMethod(int access, String methodName,
                MethodTypeDescriptor methodDescriptor, String signature, String[] exceptions) {
            if ((access & ~Modifier.methodModifiers()) != 0) {
                throw new IllegalArgumentException();
            }
            methodCount += 1;
            return new MethodCode(this, access, methodName, methodDescriptor,
                    classWriter.visitMethod(access, methodName, methodDescriptor.descriptor(),
                            signature, exceptions));
        }

        public void addField(int access, String fieldName, Type fieldDescriptor, String signature) {
            if ((access & ~Modifier.fieldModifiers()) != 0) {
                throw new IllegalArgumentException();
            }
            classWriter
                    .visitField(access, fieldName, fieldDescriptor.descriptor(), signature, null)
                    .visitEnd();
        }
    }
}
